函数：
函数名其实就是指向一个函数对象的引用，完全可以把函数名赋给一个变量，相当于给这个函数起了一个“别名”： 
>>> a = abs # 变量 a 指向 abs 函数 
>>> a(-1) # 所以也可以通过 a 调用 abs 函数
1 

定义一个函数要使用 def 语句，依次写出函数名、括号、括号中的参数和冒号:
函数体内一旦执行到 return 时，函数就执行完毕，并将结果返回
如果没有 return 语句，函数执行完毕后也会返回结果，只是结果为 None。return None 可以简写为 return
如果想定义一个什么事也不做的空函数，可以用 pass 语句： 
def nop():     
    pass
pass 可以用来作为占位符，比如现在还没想好怎么写函数的代码，就可以先放一个 pass，让代码能运行起来。 

默认参数可以简化函数的调用。设置默认参数时，有几点要注意： 
一是必选参数在前，默认参数在后，否则 Python 的解释器会报错
二是当函数有多个参数时，把变化大的参数放前面，变化小的参数放后面。变化小的参数就可以作为默认参数
当不按顺序提供部分默认参数时，需要把参数名写上
默认参数必须指向不变对象

定义可变参数和定义一个 list 或 tuple 参数相比，仅仅在参数前面加了一个*号
如果已经有一个list或者tuple，要调用一个可变参数，就在前面加一个*号，把 list 或 tuple 的元素变成可变参数传进去

可变参数允许你传入 0 个或任意个参数，这些可变参数在函数调用时自动组装为一个 tuple。
而关键字参数允许你传入 0 个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个 dict，例如：
def person(name, age, **kw):     
    print('name:', name, 'age:', age, 'other:', kw) 
函数 person 除了必选参数 name 和 age 外，还接受关键字参数 kw。在调用该函数时，可以只传入必选参数： 
>>> person('Michael', 30) 
name: Michael age: 30 other: {} 
也可以传入任意个数的关键字参数： 
>>> person('Bob', 35, city='Beijing') 
name: Bob age: 35 other: {'city': 'Beijing'} 
>>> person('Adam', 45, gender='M', job='Engineer') 
name: Adam age: 45 other: {'gender': 'M', 'job': 'Engineer'}

和可变参数类似，也可以先组装出一个 dict，然后，把该 dict 转换为关键字参数传进去： 
>>> extra = {'city': 'Beijing', 'job': 'Engineer'} 
>>> person('Jack', 24, city=extra['city'], job=extra['job']) 
name: Jack age: 24 other: {'city': 'Beijing', 'job': 'Engineer'} 
当然，上面复杂的调用可以用简化的写法： 
>>> extra = {'city': 'Beijing', 'job': 'Engineer'} 
>>> person('Jack', 24, **extra) 
name: Jack age: 24 other: {'city': 'Beijing', 'job': 'Engineer'} 
**extra 表示把 extra 这个 dict 的所有 key-value 用关键字参数传入到函数的**kw 参数，
kw 将获得一个 dict，注意 kw 获得的 dict 是 extra 的一份拷贝，对 kw 的改动不会影响到函数外的 extra
命名关键字参数可以有缺省值（分隔符*），从而简化调用：
def person(name, age, *, city='Beijing', job):     
    print(name, age, city, job)  

如果一个函数在内部调用自身本身，这个函数就是递归函数
理论上，所有的递归函数都可以写成循环的方式，但循环的逻辑不如递归清晰。 

解决递归调用栈溢出的方法是通过尾递归优化，事实上尾递归和循环的效果是一样的，
所以，把循环看成是一种特殊的尾递归函数也是可以的。
尾递归是指，在函数返回的时候，调用自身本身，并且，return 语句不能包含表达式。
这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。
 
切片（Slice）操作符
L[0:3]表示，从索引 0 开始取，直到索引 3 为止，但不包括索引 3。即索引 0，1，2，正好是 3 个元素。 
如果第一个索引是 0，还可以省略： 
>>> L[:3] 
['Michael', 'Sarah', 'Tracy'] 
同样支持倒数切片，L[-2:]表示从倒数第二个一直取到最后

前 10 个数，每两个取一个： 
>>> L[:10:2] 
[0, 2, 4, 6, 8] 
所有数，每 5 个取一个： 
>>> L[::5] 
[0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95] 
甚至什么都不写，只写[:]就可以原样复制一个 list： 
>>> L[:] 
[0, 1, 2, 3, ..., 99] 

如果给定一个 list 或 tuple，我们可以通过 for 循环来遍历这个 list 或tuple，这种遍历我们称为迭代（Iteration）
任何可迭代对象都可以作用于 for 循环，包括我们自定义的数据类型，只要符合迭代条件，就可以使用 for 循环
Python 中，迭代是通过 for ... in 来完成的
很多语言比如 C 或者 Java，迭代 list 是通过下标完成的
dict 的存储不是按照 list 的方式顺序排列，所以，迭代出的结果顺序很可能不一样
如何判断一个对象是可迭代对象呢？方法是通过 collections 模块的 Iterable 类型判断： 
>>> from collections import Iterable 
>>> isinstance('abc', Iterable) # str 是否可迭代 
True 
>>> isinstance([1,2,3], Iterable) # list 是否可迭代 
True 
>>> isinstance(123, Iterable) # 整数是否可迭代 
False
>>> isinstance([], Iterable) 
True 
>>> isinstance({}, Iterable) 
True 
>>> isinstance('abc', Iterable) 
True 
>>> isinstance((x for x in range(10)), Iterable) 
True 

enumerate 函数可以把一个 list 变成索引-元素对，这样就可以在 for 循环中同时迭代索引和元素本身
>>> for x, y in [(1, 1), (2, 4), (3, 9)]: 
...     print(x, y)
...
1 1 
2 4 
3 9 

>>> [x * x for x in range(1, 11)]
[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]

还可以使用两层循环，可以生成全排列： 
>>> [m + n for m in 'ABC' for n in 'XYZ'] 
['AX', 'AY', 'AZ', 'BX', 'BY', 'BZ', 'CX', 'CY', 'CZ']

dict 的 items()可以同时迭代 key 和 value

在 Python 中，一边循环一边计算的机制，称为生成器：generator。
第一种方法很简单，只要把一个列表生成式的[]改成()，就创建了一个 generator： 
>>> L = [x * x for x in range(10)] 
>>> L 
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81] 
>>> g = (x * x for x in range(10)) 
>>> g 
<generator object <genexpr> at 0x1022ef630>  

通过 next()函数获得 generator 的下一个返回值（但是不太常用，且要留心报错）

def fib(max):     
    n, a, b = 0, 0, 1
    while n < max:         
        print(b)         
        a, b = b, a + b
        n = n + 1 
    return 'done'
上面的函数可以输出斐波那契数列的前 N 个数
它和 generator 仅一步之遥。要把 fib 函数变成generator，只需要把 print(b)改为 yield b 就可以了，这就是第二种方法
如果一个函数定义中包含 yield 关键字，那么这个函数就不再是一个普通函数，而是一个 generator
generator 和函数的执行流程不一样。函数是顺序执行，遇到 return 语句或者最后一行函数语句就返回。
而变成generator 的函数，在每次调用 next()的时候执行，遇到 yield 语句返回，再次执行时从上次返回的 yield 语句处继续执行。 

普通函数调用直接返回结果， generator 函数的“调用”实际返回一个 generator 对象

可以被 next()函数调用并不断返回下一个值的对象称为迭代器：Iterator。 
>>> from collections import Iterator 
>>> isinstance((x for x in range(10)), Iterator) 
True 
>>> isinstance([], Iterator) 
False 
>>> isinstance({}, Iterator) 
False 
>>> isinstance('abc', Iterator)
False 
生成器都是 Iterator 对象，但 list、dict、str 虽然是 Iterable，却不是 Iterator

把 list、dict、str 等 Iterable 变成 Iterator 可以使用 iter()函数： 
>>> isinstance(iter([]), Iterator) 
True 
>>> isinstance(iter('abc'), Iterator) 
True

为什么 list、dict、str 等数据类型不是 Iterator？ 
    因为 Python 的 Iterator 对象表示的是一个数据流，Iterator 对象可以被 next()函数调用并不断返回下一个数据，
直到没有数据时抛出StopIteration 错误。可以把这个数据流看做是一个有序序列，但我们却不能提前知道序列的长度，只
能不断通过 next()函数实现按需计算下一个数据，所以 Iterator 的计算是惰性的，只有在需要返回下一个数据时它才会计算。 

for 循环本质上就是通过不断调用 next()函数实现
for x in [1, 2, 3, 4, 5]:     
    pass 
实际上完全等价于： 
it = iter([1, 2, 3, 4, 5]) # 首先获得 Iterator 对象
# 循环: 
while True:
    try:                 
        x = next(it) # 获得下一个值    
    except StopIteration:             
        break # 遇到 StopIteration 就退出循环

函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数！ 

变量可以指向函数 
函数名也是变量 （注：由于 abs 函数实际上是定义在__builtin__模块中的，所以要让修改
abs 变量的指向在其它模块也生效，要用__builtin__.abs = 10）
把函数作为参数传入，这样的函数称为高阶函数，函数式编程就是指这种高度抽象的编程范式。

