__init__方法的第一个参数永远是 self，表示创建的实例本身
有了__init__方法，在创建实例的时候，就不能传入空的参数了，必须传入与__init__方法匹配的参数，但 self 不需要传
在 Python 中，实例的变量名如果以__开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问
如果外部要获取，可以给类加个get_XXX(self)方法(return __XX)
如果要从外部修改，可以加个set_XXX(self,XXX)方法(self.__XXX = XXX )
在 Python 中，变量名类似__xxx__的，也就是以双下划线开头，并且以双下划线结尾的，是特殊变量，特殊变量是可以直接访问的，
不是 private 变量，所以，不能用__name__、__score__这样的变量名。 
看到以一个下划线开头的实例变量名，比如_name，这样的实例变量外部是可以访问的，但是，按照约定俗成的规定，
当你看到这样的变量时，意思就是，“虽然我可以被访问，但是，请把我视为私有变量，不要随意访问”。 
双下划线开头的实例变量是不是一定不能从外部访问呢？其实也不是。不能直接访问__name 是因为 Python 解释器
对外把__name 变量改成了_Student__name，所以，仍然可以通过_Student__name 来访问__name 变量

当我们定义了一个 class，创建了一个 class 的实例后，我们可以给该实例绑定任何属性和方法，这就是动态语言的灵活性
实例.属性（方法）=XXX
但是，给一个实例绑定的方法，对另一个实例是不起作用的,不过可以给class绑定方法：
fron types import MethodType
Student.set_score = MethodType(set_score, Student)
(类名.方法=MethodType(方法，类名)) 
通常情况下方法可以直接定义在类中，但是动态绑定允许我们在程序运行的过程中动态给类加上功能

要限制实例的属性，在定义 class 的时候，定义一个特殊的__slots__变量，来限制该 class 实例能添加的属性
class Student(object):     
    __slots__ = ('name', 'age') # 用 tuple 定义允许绑定的属性名称 
使用__slots__要注意，__slots__定义的属性仅对当前类实例起作用，对继承的子类是不起作用的
除非在子类中也定义__slots__，这样，子类实例允许定义的属性就是自身的__slots__加上父类的__slots__

通过多重继承，一个子类就可以同时获得多个父类的所有功能
