map()函数接收两个参数，一个是函数，一个是 Iterable，
map 将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator 返回
>>> def f(x): 
...     return x * x 
... 
>>> r = map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9]) 
>>> list(r)
[1, 4, 9, 16, 25, 36, 49, 64, 81]

reduce 把一个函数作用在一个序列[x1, x2, x3, ...]上，这个函数必须接收两个参数，
reduce 把结果继续和序列的下一个元素做累积计算
reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)

对一个序列求和，就可以用 reduce 实现： 
>>> from functools import reduce 
>>> def add(x, y): 
...     return x + y 
... 
>>> reduce(add, [1, 3, 5, 7, 9])
25 
要把序列[1, 3, 5, 7, 9]变换成整数 13579:
>>> from functools import reduce 
>>> def fn(x, y): 
...     return x * 10 + y 
... 
>>> reduce(fn, [1, 3, 5, 7, 9]) 
13579

Python 内建的 filter()函数用于过滤序列。 
filter()接收一个函数和一个序列。和 map()不同的时，filter()把传入的函数依次作用于每个元素，
然后根据返回值是 True 还是 False 决定保留还是丢弃该元素

Python 内置的 sorted()函数可以对 list 进行排序
sorted()函数是一个高阶函数，它还可以接收一个 key 函数来实现自定义的排序，例如按绝对值大小排序： 
>>> sorted([36, 5, -12, 9, -21], key=abs)
[5, 9, -12, -21, 36]
默认情况下，对字符串排序，是按照 ASCII 的大小比较的
忽略大小写的排序： key=str.lower

匿名函数 lambda x: x * x 实际上就是： 
def f(x):     
    return x * x 
关键字 lambda 表示匿名函数，冒号前面的 x 表示函数参数。 
匿名函数有个限制，就是只能有一个表达式，不用写 return，返回值就是该表达式的结果
用匿名函数有个好处，因为函数没有名字，不必担心函数名冲突。此外，匿名函数也是一个函数对象，
也可以把匿名函数赋值给一个变量，再利用变量来调用该函数： 
>>> f = lambda x: x * x 
>>> f 
<function <lambda> at 0x101c6ef28> 
>>> f(5) 
25 
同样，也可以把匿名函数作为返回值返回，比如： 
def build(x, y):     
    return lambda: x * x + y * y 

函数对象有一个__name__属性，可以拿到函数的名字
在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator）
def log(func):     
    def wrapper(*args, **kw):
            print('call %s():' % func.__name__)
            return func(*args, **kw)     
    return wrapper
要借助 Python 的@语法，把 decorator 置于函数的定义处
@log 
def now():
    print('2020-2-21') 
把@log 放到 now()函数的定义处，相当于执行了语句： 
>>>now = log(now)
wrapper()函数的参数定义是(*args, **kw)，因此，wrapper()函数可以接受任意参数的调用。
要自定义 log 的文本： 
def log(text):
    def decorator(func):         
        def wrapper(*args, **kw):             
            print('%s %s():' % (text, func.__name__))             
            return func(*args, **kw)         
        return wrapper     
    return decorator  
这个 3 层嵌套的 decorator 用法如下： 
@log('execute') 
def now():     
    print('2020-2-21') 
执行结果如下： 
>>> now() 
execute now(): 2020-2-21
3 层嵌套的效果是这样的： 
>>> now = log('execute')(now)

偏函数:
int()函数还提供额外的 base 参数，默认值为 10。如果传入 base 参数，就可以做 N 进制的转换： 
>>> int('12345', base=8) 
5349
>>> int('12345', 16)
74565 
functools.partial 就是帮助我们创建一个偏函数的
>>> import functools 
>>> int2 = functools.partial(int, base=2) 
>>> int2('1000000')
64 
>>> int2('1010101')
85
创建偏函数时，实际上可以接收函数对象、*args 和**kw 这 3 个参数，当传入： 
int2 = functools.partial(int, base=2)
相当于： 
kw = { 'base': 2 } 
int('10010', **kw)   
当函数的参数个数太多，需要简化时，使用 functools.partial 可以创建一个新的函数，
这个新函数可以固定住原函数的部分参数，从而在调用时更简单


