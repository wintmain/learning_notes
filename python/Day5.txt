https://docs.python.org/3/library/functions.html 内置函数学习
https://www.python.org/ python官方
https://pypi.python.org/ 第三方库文档查询
注意，每一个包目录下面都会有一个__init__.py 的文件，这个文件是必须存在的，
否则，Python 就把这个目录当成普通目录，而不是一个包。
__init__.py 可以是空文件，也可以有 Python 代码，因为__init__.py 本身就是一个模块，而它的模块名就是包名
任何模块代码的第一个字符串都被视为模块的文档注释

if __name__=='__main__':     
    test()
if 测试可以让一个模块通过命令行运行时执行一些额外的代码，最常见的就是运行测试。 

正常的函数和变量名是公开的（public），可以被直接引用，比如：abc，x123，PI 等
类似_xxx 和__xxx 这样的函数或变量就是非公开的（private），不应该被直接引用，比如_abc，__abc 等；
不应该被直接引用不表示不能引用：
def _private_1(name):     
    return 'Hello, %s' % name 
def _private_2(name):     
    return 'Hi, %s' % name  
def greeting(name):     
    if len(name) > 3:         
        return _private_1(name)     
    else:         
        return _private_2(name)
在模块里公开 greeting()函数，而把内部逻辑用 private 函数隐藏起来了，
这样，调用 greeting()函数不用关心内部的 private 函数细节，这也是一种非常有用的代码封装和抽象的方法，即： 
外部不需要引用的函数全部定义成 private，只有外部需要引用的函数才定义为 public

类似__xxx__这样的变量是特殊变量，可以被直接引用，但是有特殊用途，比如__author__，__name__就是特殊变量，
模块定义的文档注释也可以用特殊变量__doc__访问，我们自己的变量一般不要用这种变量名

用于科学计算的 NumPy 库：numpy
用于生成文本的模板工具 Jinja2

默认情况下，Python 解释器会搜索当前目录、所有已安装的内置模块和第三方模块，搜索路径存放在 sys 模块的 path 变量中
>>> import sys 
>>> sys.path 

如果我们要添加自己的搜索目录，有两种方法： 
一是直接修改 sys.path，添加要搜索的目录： 
>>> import sys 
>>> sys.path.append('XXX(目录)') 
这种方法是在运行时修改，运行结束后失效。 
第二种方法是设置环境变量 PYTHONPATH，该环境变量的内容会被自动添加到模块搜索路径中。
设置方式与设置 Path 环境变量类似。注意只需要添加你自己的搜索路径，Python 自己本身的搜索路径不受影响。




# I/O编程
通常，程序完成 IO 操作会有 Input 和 Output 两个数据流。当然也有只用一个的情况，
比如，从磁盘读取文件到内存，就只有 Input 操作，反过来，把数据写到磁盘文件里，就只是一个 Output 操作 
CPU的状态可以将I/O分为，同步和异步，区别就在于是否等待 IO 执行的结果
异步 IO 来编写程序性能会远远高于同步 IO，但是异步 IO 的缺点是编程模型复杂，复杂度远远高于同步 IO

文件读写：
要以读文件的模式打开一个文件对象，使用 open() 函数，传入文件名和标示符
read()方法可以一次读取文件的全部内容
close()方法关闭文件
try:     
    f = open('/path/to/file', 'r')     、
    print(f.read())
finally:     
    if f:         
        f.close()

Python 引入了 with 语句来自动帮我们调用 close()方法： 
with open('/path/to/file', 'r') as f:     
    print(f.read()) 
这和前面的 try ... finally 是一样的，但是代码更佳简洁，并且不必调用 f.close()方法 
反复调用 read(size)方法，每次最多读取size 个字节的内容。调用 readline()可以每次读取一行内容，
调用 readlines()一次读取所有内容并按行返回 list
for line in f.readlines():
    print(line.strip()) # 把末尾的'\n'删掉 

要读取二进制文件，比如图片、视频等等，用'rb'模式打开文件即可
要读取非UTF-8编码的文本文件，需要给open()函数传入encoding参数，如:
f = open('/Users/michael/gbk.txt', 'r', encoding='gbk')
在文本文件中可能夹杂了一些非法编码的字符。遇到这种情况，open()函数还接收一个 errors 参数，
表示如果遇到编码错误后如何处理。最简单的方式是直接忽略： 
f = open('/Users/michael/gbk.txt', 'r', encoding='gbk', errors='ignore')  

写文件和读文件是一样的，唯一区别是调用 open()函数时，传入标识符'w'或者'wb'表示写文本文件或写二进制文件
要写入特定编码的文本文件，请给 open()函数传入 encoding 参数，将字符串自动转换成指定编码

在内存中读写：
from io import StringIO
f = StringIO()
f.write('XXX')...# 写入str
print(f.getvalue()) #获得写入后的str

from io import StringIO
f = StringIO('Hello!\nHi!\nGoodbye!') # 用一个 str 初始化 StringIO
while True:
    s = f.readline()     
    if s == '':       
        break     
    print(s.strip()) 

要操作二进制数据，就需要使用BytesIO

把变量从内存中变成可存储或传输的过程称之为序列化
把变量内容从序列化的对象重新读到内存里称之为反序列化
Python 提供了 pickle 模块来实现序列化
pickle.dumps()方法把任意对象序列化成一个 bytes
用pickle.loads()方法反序列化出对象
with open('dump.txt','wb') as f:
    pickle.dump(d,f) # 写入

with open('dump.txt','rb') as f:
    pickle.load(f) # 反序列化

JSON 表示出来就是一个字符串，可以被所有语言读取，也可以方便地存储到磁盘或者通过网络传输。
JSON 不仅是标准格式，并且比 XML 更快，而且可以直接在 Web 页面中读取，非常方便


