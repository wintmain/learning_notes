# 软件工程

首先，说一下考试卷的组成。我们考试满分100分。最终成绩=0.6*考试成绩+0.25*实验总成绩+0.15*作业总成绩。
考试题型：
选择题：15道；每道1分，共15分
填空题：10空；每空2分，共20分
问答题：5道；每道6分，共30分
设计题：3道；共35分。
考试范围：问答题基本围绕PPT上标红的知识点，知识点如果过于精炼，使你不能马上理解，可翻书找到对应的地方。
选择、填空、问答就不说了，太幼稚。
分析设计，3个案例，每个案例对应一种题，也就是你们作业涉及到的：根据需求陈述画分层数据流图；根据系统描述建立对象模型；给个子程序，让你测试测试，给出测试用例。
所以你看，卷子乍一看，非常唬人！其实是纸老虎，要好好读题。我只能告诉你们，不难，但也需要动动心思。

另外，我的考试有几个要求，注意听好！违者，赐一丈红！
第一：考试期间，不允许上厕所。自己考前都解决好了，你说你肾不好、还拉稀。。。我还腰不好、有痔疮呢！别整没用的，想出去抄小条，厕所捡答案，门都没有！
第二：不允许提前交卷！不允许提前交卷！不允许提前交卷！重要的问题重复3次。老虎也有打盹的时候，万一监考的转个身，腰扭了，没回过身，对吧，不要放弃希望！
第三：带“小条”尤可恕，电子作弊不可活！知道什么叫高科技作弊么？我也是来了**才知道。用手机，加什么考试作弊群，智能手表，对了，还有口罩，这些心思就别动了！去年帮朋友监考，抓了两个，听说还有考试群！很尴尬！你加了考试群就别来了，作弊算违纪，但你加了群就违法了。
第四：考3年了，规矩都懂。学生卡都带着！

计划：
今天：DFD
明天：该死的测试
后天：“玩”明白对象

测试题的步骤：
主要看步骤：上来，先给我回答定义。
然后，列出分析过程，因为只有给出了分析过程，才能找到最小的测试用例组。
最重要别忘了，有了测试用例，还要给出该测试用例的预期输出结果。

理论上，每一道题拿出来，考判定、条件、判定/条件、条件组合，都能出一道题。一点一点的增加难度都是可以的。我的PPT上的例子，就是同一个例子用了四种测试方法。这里面，不要侥幸说，我只会一种就行。考哪种方法随机的，所以，都要看看，看会。
黑盒测试的部分也要看，虽然我不考黑盒的测试用例（划重点），但是概念性的东西你要清楚。

测试的部分，课程PPT上的例子很好，兼顾了所有的可能，我的建议是好好看看。如果实在不能领悟，就把概念背下来，2分就有了。分析过程，你不会怎样得出测试用例，题干中的条件和判断你总能看出来吧，一一列出来，就一半分了。最少测试用例，你给不出来，多给几个你总会吧？1分，总要给吧，所以算下来，学渣们，也扣不了几分了。最忌讳的是，你给我来个艺术家气质，大量留白，只签个名，我的欣赏水平只局限于小学水平，就喜欢一张纸上满满当当的。

## 第一章概论

软件在计算机系统中与硬件相互依存，包括程序、相关数据及其说明文档。

## 第二章可行性研究与需求分析

根据题意，一段需求陈述，导出数据流图一般可以分为几个步骤：
（1）顶层DFD：确定整个系统的输入数据流及其源点、输出数据流及其终点；把整个系统作为一个处理（加工）。
（2）一层DFD：确定系统的主要处理功能，按此将整个系统（顶层DFD中的处理）分解成若干个处理（加工），确定每个处理的输入与输出数据流以及与这些处理有关的数据存储。
（3）根据自顶向下，逐层分解的原则，对上层图中全部或部分处理进行分解。
（4）重复步骤（3），直到逐层分解结束。

我们就用这张图说事儿。
我们画数据流图，可以说主要分成3个步骤：第一，确定系统范围，找到数据源点和数据终点。第二，确定系统主要处理功能，然后将系统分解成若干个处理，确定数据流和与之相关的数据存储。第三，继续分解处理，直到逐层分解结束。这个过程，你说3步或4步都是可以的，主要原则：自顶向下，逐步分解。
这里要注意，考试我只要求你画0层（顶层）和1层，切记不要过度分解。我上课的讲的是分解3层：顶层、1层、和2层。
DFD的绘制步骤，记住了。起码记住了，你画出来的那个人不像人、鬼不像鬼的印象派，至少长相不会出大错。
然后再思考：绘制分层数据流图，有哪些注意事项？

@全体成员
 也做一个总结。
首先：编号。也就是处理的编号。其次，被分解后的子图要与上一层的图保持平衡，也就是说，输入数据流和输出数据流要保持上下层一致。还有一点最重要，基本上这一点能帮助很多学也学不会，画也画不明白的同学挣点分——————就是——————1层出现了数据存储————切记————————帮你多得2分。
然后，组层分解处理。分解的详尽程度，由1层到2层是个逐步的过程。
最后，也是很好的得分点。我们说良好合理的命名，对成长有助益。数据流由于处理的分解，会在处理和存储之间更细化，但一定是你输入数据流和输出数据流的子集。
我们的第二个作业上的DFD，是个蛮不错的例子。
讲一下喽！

你要**确定数据源点** 很容易，就是看有没有什么东西、什么人向系统提出了请求或者，向系统录入了什么，或者向系统提交了什么等等，有没要要求系统做什么的这类。

数据源点或者终点用矩形框表示
系统名称用椭圆（圆角矩形）表示

注意：顶层（0层）数据流图描绘的是系统的概貌，是系统最抽象的表示方式，说白了，就是系统与外部交互的情况，系统内部的运行方式，还没有被分析出来，得一步一步来。

@全体成员
考试时，每个人都有一张草稿纸，要善用。不要上来就画到答题卡上。因为，向下分解时，如果没有规划好，容易产生交叉线，不好处理。书写时，要工整一点，这样起码印象分会很容易得。比如，你只有一点小错误，可是，十分工整，工整到我要洗了手才敢翻动，恭喜你，我可以无视这个小错。比如，你不会，然后你选择鬼画符，那么你更要工整点，知道什么是同情分么？我这人，就见不得态度好的，态度好，啥都好说！多要几分？给！想创业要投资？给！就这脾气。态度不好，我态度也不好。明？

再提一个考试要求：卷子上，不允许有空的题。不会，编！抄题！谈谈理想！有一种分叫过程分，明？还有一种分叫辛苦分？明？劈情操劈的明白，2分起给。抄题1分。理解答题，2分起给！

按照题意，我们分析一下，可以分成几个处理？
有简入难——首先，其实一下能看到，肯定要一个处理，是处理查询的对么？ 注意看：经理的输入和输出。
然后肯定还得有个管理销售的处理吧？
而且
既然，有出入库商品的输入和库存清单的输出，估计库存管理的处理也少不了吧？
这里，如果没有看清题意，根据常识，其实也能分解出来，就好比一个系统下面的子系统。只不过，在1层，极有可能过度分解了，把2层的也给分解出来了。。。。这个时候，要考虑：你分解出来的1层处理，还有没有可能被分类。如果1层的处理中，有两个或以上的处理，能被归为一类（可参考抽象的方法，看看自己分解好的处理属于同一个概念），不用想，肯定分解多了。如果不能分类，基本上都能对。
除此之外：1层的标志：出现了存储！

这里就是我要说的能不能分类的问题。首先1层分解，是把系统的主要功能分解出来，你也可以理解为分解了子系统。处于比较抽象，尚不具体的状态。此时如果你分解出来的处理能够被分为一类，就等同说，你分解出来的处理是解决同一类事情的。打印处理，和系统处理完查询返回的结果是不是包含关系？

存储，说白了，映射成最终系统的时候，其实就是数据库或者说表，再或者说就是产生了增删改查等动作。

这里出现了编号（得分点）！而且，与顶层的输入、输出数据流保持了一致（得分点）。还有存储（得分点）。
中间和存储相连的数据流，如果你不确定，该写啥，题目也没有明显给出，那么，你可以和数据源点出发的、流入数据终点的保持一致，我也算你对（注意：子父图平衡，除了源点、重点一致以外，数据流的上下一致也同样关键，这里也是得分点）。比如：销售员这个数据源点，输入数据流时销售信息，经过销售管理处理后的数据流也可以直接写成销售信息，同理：从存储出去的数据流也可写成销售信息。明？

第2层！
我记得，我上课讲过一个小窍门（可回去自行翻阅超星平台课程视频第2张DFD那）：第二次和第一层不同在于，1层与存储交互的数据流，进和出都走进了一个处理里面，那么在第2层，要把这个进、和出分开。基本上进出有几条数据流，就可以分解成几个相应的处理。。。记得么？
敲黑板！这个时候，如果你光读题面，有可能读不出来具体的要求。所以，我们有时候需要有分解处理的思维。我上课讲过，写代码时，你怎么嵌套都行，怎么设计逻辑关系都行，但始终，单入单出肯定要做到。在DFD上，也可以这样理解。

好，这里就涉及到了一个非常重要的地方——首先，很多处理都加上了限定条件。其次，数据源点、终点，或者说题目都没有罗列清楚，对么？
如果，考试我要增加难度，说白了，也就是这样。混淆视听，看着无从下手，其实没什么深度。
对于数据源点和终点，题目罗列不清，但是又有数据流，那么这样的题，就有了一个分析的过程。购物清单作为数据流，发送给谁，通过尝试判断就可以了。商场的管理系统，使用人群都有谁？这是其一，其二，系统给出了数据流，不可能没有相应的数据终点对么？
根据常识，顾客也是使用管理系统的人群，就像，一个教务系统，我不说是给谁用的，你猜也知道，用户一定是学生和老师。酒店管理系统不仅有前台，肯定还有住客。图书管理系统不仅有管理员，肯定也有老师、学生。一个道理。这个时候，要考虑：如果系统给出了数据流，那么根据常识，这个数据流就一定有源点，或终点。即使题面没给，也要判断出来。
第二，系统处理的限定条件，对绘制一个数据流图有没有影响？
DFD，只反映数据的流向，处理的逻辑和必要的数据存储。不反应处理逻辑的先后关系，也不反应控制关系，调用关系，控制流。也就是说，DFD仅以数据流的形态反映一个系统管理业务的过程。
所以，一道DFD的题，无论多复杂，限定条件多么多，你们都要绕出来。这也是我今天关于DFD答疑最后要说的事情。

最后留一道练习题吧，明天白天，或漫漫长夜可以练练手。

题目如下：
各种病症监视器安置在每个病床旁，将病人的病症信号实时的传送到中央监护系统进行分析处理。在中心值班室里，护士使用中央监护系统对病员的情况进行监控，监护系统实时地将病人的病症信号与标准的病症信号进行比较分析，当病症出现异常时，系统会立即自动报警，并实时打印病情报告和更新病例。未报警时，系统定期自动更新病例。护士还可以根据医生的要求随时打印病人的各类病情报告。
1）绘制该系统的顶层数据流图；
2）绘制该系统的1层数据流图；

## 第三章总体设计

### 软件设计概述

软件设计分为总体设计（概要设计）和详细设计两个阶段
（1）总体设计：
将软件需求转化为系统结构（程序结构、接口）和数据结构。
通过仔细分析软件需求规格说明，确定组成系统的模块及各模块之间的关系，设计出完成预定功能的模块结构（软件结构），并建立接口。
（2）详细设计：
详细地设计每个模块，即确定完成每个模块功能所需要的**算法和数据结构**。

（1）数据设计：将分析阶段的信息域模型（**E-R图、数据字典**）转变成实现软件所需要的数据结构
（2）体系结构设计：将分析阶段的**功能模型（DFD）** 转变成软件的模块框架
结构化分析结果为结构化设计提供了最基本的输入信息
（3）接口设计：根据分析阶段的**功能模型（DFD）**，描述软件内部、软件与协作系统之间、软件与用户之间的通信方式
（4）过程设计（详细设计）：根据**数据流图**中每个处理的要求及分析阶段的行为模型（**状态转换图**）设计每个模块的实现过程

### 软件设计的原理

（1）模块：模块是由边界元素限定的程序单元，是构成程序的基本构件，是指用一个名字可以调用的一段程序语句。
（2）模块化：模块化就是将程序划分成独立命名且可独立访问的若干模块，每个模块完成一个子功能；将模块集成起来构成一个整体，完成指定的系统功能。
（3）抽象：抽出事物的本质特性而暂时不考虑其细节的思维方式。
处理复杂系统的有效的方法：分层次构造和分析。
软件工程过程的每一步都是对软件解法的抽象层次的一次精化。
（4）逐步求精：为了能集中精力解决主要问题而尽量推迟对问题细节的考虑
Miller法则：
一个人在任何时候都只能把注意力集中在(7±2)个知识块上。
（5）信息隐藏原理：
一个模块内包含的信息(过程和数据)对于不需要这些信息的模块来说，是不能访问的。
（6）模块独立性
软件结构中的每个模块完成一个相对独立的特定子功能，并且和其它模块的接口是简单的。
度量标准：高内聚，低耦合。

+ 耦合表示一个软件结构内不同模块之间的互连程度。

> 耦合由弱到强：数据耦合→控制耦合→特征耦合→公共环境耦合→内容耦合
（1）数据耦合：模块间通过参数交换数据。
（2）控制耦合：模块间通过参数交换控制信息。
（3）特征耦合：主调模块将整个数据结构作为参数传递，而被调模块只需要其中的一部分数据元素。
（4）公共环境耦合：一组模块通过一个公共数据环境相互作用。
（5）内容耦合：①一个模块访问另一个模块的内部数据。②一个模块不通过正常入口转到另一模块的内部。③两个模块有一部分程序代码重叠。④一个模块有多个入口。

+ 内聚标志着一个模块内各个元素彼此结合的紧密程度。

> 内聚由弱到强:偶然内聚→逻辑内聚→时间内聚→过程内聚→通信内聚→顺序内聚→功能内聚
（1）偶然内聚：模块内各元素之间关系松散。表现在模块没有明确功能或模块包括彼此无关的一组功能。
（2）逻辑内聚：一个模块内的各功能在逻辑上相同或相似。把几种相关的功能组合在一起，每次调用时，由传送给模块的判定参数来确定该模块应执行哪一种功能。
（3）时间内聚：一个模块内各功能须在同一时段内完成，时间内聚模块的各功能可以以任意的顺序执行，所以它的内部逻辑简单、存在的开关(或判定)转移较少。
（4）过程内聚：模块内各个部分彼此相关，必须按特定的次序执行。仅包括完整功能的一部分，所以它的内聚程度仍然较低。
（5）通信内聚：模块内各功能使用同一个输入或产生同一个输出，包括了若干独立的功能。它容易产生重复的联结或重复的功能。
（6）顺序内聚：模块内各处理元素与同一个功能密切相关，且必须顺序执行，即前一个处理动作产生的输出数据是下一个处理动作的输入数据。
（7）功能内聚：模块内各部分属于一个整体、为完成一项单一功能而协同工作、不可分割。

### 表示软件结构的图形工具

层次图：表示了模块和模块间的调用关系。

HIPO图：用H图表示模块和模块间调用关系；用IPO图表示各个模块的处理过程

结构图：
①表示模块及模块间的调用关系；
②表示模块间的信息传递

### 软件结构中的启发规则

(1)改进软件结构提高模块独立性：
通过**分解或合并模块**
(2)每个模块的规模适中
(3)深度、宽度、扇出和扇入要适当
顶层模块**扇出大**、中层模块**扇出较小**，底层模块**扇入大**
> 模块的扇出：模块直接调用的子模块数目
模块的扇入：直接调用该模块的上层模块数目
结构图的深度：模块结构图的**层次数**
结构图的宽度：模块结构图中**同一层模块数目的最大值**

(4)模块的作用域应在控制域之内
> 模块的作用域：受该模块内一个判定影响的所有模块集合
模块的控制域：模块本身及其所有从属模块。

(5)力争降低模块接口的复杂程度
(6)设计单入口单出口的模块
(7)模块功能应该可以预测

### 面向数据流的设计方法

设计步骤：
(1)根据数据流图决定问题类型
(2)根据问题类型，进行**变换分析或事务分析**，导出系统结构图。
(3)改进系统结构图。

① 变换型问题数据流图的构成
信息沿输入通路进入系统、同时由外部形式(**物理输入**)变换成内部形式(**逻辑输入**)；进入系统的信息通过变换中心，经加工处理以后的结果(**逻辑输出**)再沿输出通路变换成外部形式(**物理输出**)离开软件系统。
步骤：
(1) 分析具有变换特征的数据流图，确定输入流和
输出流的**边界**、孤立出**变换中心**
(2) 完成一级分解，设计软件结构的顶层和第二层
(3) 完成二级分解：把数据流图中的每个处理映射成软件结构中一个适当的模块
(4)精化软件结构：适当分解或合并模块
(5)简要描述每个模块（可以用IPO图描述）

② 事务型问题数据流图的构成
步骤：
(1) 由事务型数据流图映射成的软件结构包括**一个接收分支和一个发送分支**。
(2) 映射出接收分支结构的方法和变换分析映射出输入结构的方法很相像，即从事务中心的边界开始，把沿着接收流通路的处理映射成模块。
(3) 发送分支的结构包含**一个调度模块**，它控制下层的所有活动模块；然后把数据流图中的每个活动流通路映射成与它的流特征相对应的结构。

一般说来，如果数据流不具有显著的事务特点，最好使用变换分析；反之，如果具有明显的事务中心，则应该采用事务分析技术。

软件优化原则：先使它能工作，然后再使它快起来。

### 人机界面设计

人机界面设计中需要考虑的主要问题如下：
（1）命令／图形交互；
（2）系统响应时间；
（3）用户帮助设施；
（4）出错信息处理。

交互界面设计考虑的问题：
◆ 保持**一致性**。
◆ 提供有意义的**反馈**。保证在用户和界面之间建立双向通信。
◆ 在执行有较大破坏性的动作之前要求用户**确认**。
◆ 允许取消绝大多数操作。提供**UNDO操作**。
◆ 减少在两次操作之间必须**记忆**的信息量。
◆ 尽量减少**击键次数**，减少**鼠标移动**的距离。
◆ **健壮性**。系统应该保证不受致命错误的破坏。
◆ 提供**帮助**设施。

查询界面设计考虑的问题：
◆ 只显示与当前工作**内容**有关的信息。
◆ 显示的**含义**应该非常明确。
◆ 允许用户保持**可视化**的语境。
◆ 产生有意义的**出错信息**。
◆ 使用**窗口分隔**不同类型的信息。
◆ 高效率地使用显示屏。

## 第四章详细设计

### 详细设计的任务及目标

任务：
（1）确定软件各个组成部分（模块）的**内部算法**以及各部分的**内部数据结构**;
（2）选定某种过程表达形式来**描述算法**。
（3）进行详细设计的评审。

不是具体地编写程序，而是要设计出程序的“蓝图”。

### 详细设计的原则

1.模块的逻辑描述一要清晰易读，二要正确可靠；
2.采用结构化设计方法，改善控制结构，降低程序复杂程度，提高程序的可读性、可测试性和可维护性；
3.选择适当的描述工具来描述模块的算法。

#### 详细设计的方法和工具

结构化程序设计方法：
1．采用**自顶向下、逐步求精**的程序设计方法
2．使用三种基本控制结构构造程序
任何程序都可由**顺序、选择及循环**三种基本控制结构构造。

详细设计描述工具：
(1)图形工具：程序流程图、N-S图（盒图）、PAD图（问题分析图）
(2)表格工具：判定表 、判定树
(3)语言工具：过程设计语言（PDL）

### 详细设计的规格说明及复审

详细设计说明书的内容主要包括:
(1) 表示软件结构的图表。
(2) 对逐个模块的程序描述，包括算法和逻辑流程。
设计复审是指对设计文档的复审：
1.复审的指导原则
(1)一般不邀请用户和其他领域的代表；
(2)应持积极态度，接受建议与批评。参加者应为文档修改创造和谐气氛。
(3)详细记录问题，但不要求当场解决。
(4)复审结束前做出本次复审能否通过的结论。
2.复审的主要内容
重点应放在各个模块的具体设计上，例如模块的设计能否满足其功能与性能要求，选择的算法与数据结构是否合理，是否符合编码语言的特点，设计描述是否简单、清晰等。
3. 复审的方式
复审分为正式与非正式两种方式，非正式复审特点是参加人数少，且均为软件人员，带有同行讨论的性质，因而方便灵活，十分适合于详细设计复审。

### 面向数据结构的设计方法

Jackson图：
数据元素的逻辑关系：顺序，选择和重复
> 选择的右上角有°标志，重复的右上角有*标志

优点：可以清楚的表示数据的层次结构，形象直观易读。同时它既可表示数据结构，也可表示程序结构。
Jackson图和层次图区别：
层次图中的一个方框通常代表一个模块，Jackson图中一个方框只代表几条语句
层次图表现的是调用关系，Jackson图表现的是组成关系

## 第五章编码及测试

### 编码

第一代语言是机器语言
第二代语言是汇编语言
第三代语言是高级程序设计语言

编码风格：
(1)源程序文档化：

+ 恰当的标识符命名

> 模块名、变量名、常量名、标号名、子程序名、数据区名以及缓冲区名等

+ 适当的注释

> 注释分为序言性注释和功能性注释

+ 良好的视觉组织

> 恰当的利用空格、空行和移行(向右缩格)

(2)数据说明：次序规范；对复杂数据结构加注释。

+ 程序中**数据说明次序**

> ①常量说明 ②简单变量说明 ③数组说明
④公用数据说明 ⑤文件说明

+ 可按如下顺序排列**类型说明**

> ①整型量说明 ②实型量说明 ③字符量说明
④逻辑量说明

+ 当多个变量在一个说明语句中说明时，按字母顺序排列

(3)语句构造
每个语句简单而直接(可读性最重要)

(4)输入和输出
输入的检查；输入项组合的合法性检查；
数据的简单格式和结束标记；交互时的提示。

效率
1.效率是性能指标，在需求分析阶段给出目标值
2.不要牺牲程序的清晰性和可读性来提高效率
3.靠良好的设计来提高效率
（1）程序运行时间
详细设计阶段确定的**算法**是影响程序效率的决定因素。
（2）存储器效率
大型机：考虑操作系统页式调度的特点。
微型机：采用有紧缩存储器特性的编译程序。
（3）输入/输出效率
设置缓冲，减少通信开销
辅存的I/O：简单的存取方法，成块传送

### 软件测试基础

测试就是**为了发现程序中的错误而执行程序的过程**
**测试用例**：输入数据及预期输出结果。原则：**选用少量“最有效的”测试数据**，基本目标：确定一组最可能发现某个或某类错误的测试数据。

测试过程则是自底向上、逐步集成的过程。低一级测试为高一级测试准备条件

软件测试横跨编码和测试两个阶段。

### 白盒测试技术

关注软件产品的内部细节和逻辑结构

逻辑覆盖：以程序内部逻辑结构为基础，通过对程序逻辑结构遍历实现程序测试的覆盖。
**有选择地执行程序中某些最有代表性的通路**是对穷尽测试的唯一可行的替代办法。
覆盖是对一系列测试过程的总称，这组测试过程逐渐进行越来越完整的通路测试。

1.语句覆盖：每一可执行语句至少执行一次。
2.判定覆盖：使每个判定的每种可能结果至少执行一次。
3.条件覆盖：每个判定表达式中每个条件的可能取值至少执行一次。
4.判定/条件覆盖：每个判定表达式中每个条件的可能取值至少执行一次；同时每个判定表达式的可能判定结果至少执行一次。
5.条件组合覆盖：每个判定表达式中的所有可能的条件取值组合至少执行一次。

控制结构测试
基本路径测试步骤：
(1)根据详细设计结果画出相应的流图，求环形复杂度。
(2)确定线性独立路径的基本集合：

+ 环路复杂度取值表示程序的独立路径条数
+ 独立路径：包括一组新的处理语句或新条件的一条路径

(3)设计可强制执行基本路径集合中的每条独立路径测试用例

基本路径覆盖是一种**很强的覆盖标准**，它使得程序中的**每个条件至少取得一次真值和假值**，使得**每条语句至少执行一次**

循环测试
三种循环：简单，嵌套，串接
嵌套循环的测试：
①从最内层循环开始测试，把所有其他循环都设置为最小值。
②对最内层循环使用简单循环测试方法，而使外层循环的迭代参数(例如，循环计数器)取最小值，并为越界值或非法值增加一些额外的测试。
③由内向外，对下一个循环进行测试，但保持所有其他外层循环为最小值，其他内层嵌套循环为“典型”值。
串接循环的测试：
①如果串接的各个循环彼此独立，可以使用简单循环的测试方法。
②如果两个循环串接，而且第一个循环的循环计数器值是第二个循环的初始值，则两个循环并不是独立的。可以使用嵌套循环的测试方法。

选择测试方法的经验
在单元测试阶段，以代码检查、覆盖测试为主；
在集成测试阶段，需要增加静态结构分析等；
在系统测试阶段，应根据黑盒测试的结果，采用相应的白盒测试方法 。

### 黑盒测试技术

黑盒测试主要试图发现下列几类错误:
1、**功能**不正确或遗漏；
2、**界面**错误；
3、**数据结构和数据访问**错误；
4、**性能**错误；
5、**初始化和终止**错误等。

#### 等价划分

把程序的可能的输入数据（或输出数据）划分成若干部分（**等价类**），然后从每一部分中选取少数有代表性的数据作为测试用例。
**测试某等价类的代表值就等价于对这一类其它值的测试。**

①有效等价类：合理的、有意义的数据构成的集合。
②无效等价类：不合理、无意义的数据构成的集合。

启发规则：
①若输入条件规定了**取值范围或取值个数**，则可确定**一个有效等价类**和**两个无效等价类**。
若输入数据为数值型，则可划分出正数、零和负数三
个有效等价类
②若规定了输入数据的一组值，而且程序要对每个值分别处理，则可为每个输入值确立**一个有效等价类**（允许输入值）；为这一组值确立**一个无效等价类**（任一个不允许的输入值）。
③若规定了输入数据必须遵守的规则，则可确立**一个有效等价类**（符合规则）和若干个无效等价类（从不同角度违反规则）。
④若程序的处理对象是表格，则应该使用空表、含一项、
含多项的表。

如何确立测试用例：
①设计一个新的测试用例，使其尽可能多地覆盖尚未被覆盖的有效等价类（重复这一步，直到所有的有效等价类都被覆盖为止）
②设计一个新的测试用例，使其仅覆盖一个尚未被覆盖的无效等价类（重复这一步，直到所有的无效等价类都被覆盖为止）

等价划分法测试步骤：
（1）确定等价类（包括合理等价类和不合理等价类）并顺序编号；
（2）确定测试用例：
一个测试用例可以覆盖**多个合理等价类**
一个测试用例只能覆盖**一个不合理等价类**

#### 边界值分析

设计**使程序运行在边界情况附近的测试方案**、暴露出程序错误的可能性会更大些。
选择等价类的边界值作为测试用例
取输入等价类和输出等价类的边界值及边界附近的值做测试用例

#### 其他

错误推测法
列举出程序中可能有的错误和容易发生错误的特殊情况，并且根据它们选择测试方案
因果图法
从自然语言书写的程序规格说明书中寻找因果关系，即输入条件与输出和程序状态的改变，通过因果图产生判定表

### 软件测试过程及策略

#### 1.单元测试

对用源代码实现的**每一个程序模块**进行测试
> 检查每个单元（模块）**控制结构中的特定路径**，以确保做到完全覆盖并发现最大数量的错误。
检查各个模块是否正确地实现了**规定的功能**
主要发现**编码和详细设计的错误**

（1）单元测试集中检测软件设计的最小单元——模块
用详细设计结果作指南，对重要的执行通路进行测试
各模块可平行、独立进行单元测试

主要使用白盒测试技术、辅助使用黑盒测试技术

（2）单元测试的内容
模块接口测试
局部数据结构测试（数据类型、初始化、类型匹配）
内部逻辑测试（基本执行路径和循环）
错误处理的测试（出错预见、出错处理）
边界测试（数据流、控制流的边界）
某些性能测试

（3）单元测试的步骤
a.测试用例设计：利用设计文档，设计验证程序功能、检查逻辑路径、找出程序错误的多个测试用例。
b.设计辅助模块（测试软件）：考虑该模块与外界的联系，通常用一些辅助模块去模拟与被测模块相联系的其他模块
c.进行测试运行、分析测试结果

> 辅助模块就是驱动模块和桩模块（存根模块）：
①驱动模块：
相当于被测模块的上级调用模块；接收测试数据并传给被测模块；输出实测结果。
②桩模块（存根模块）：
代替被测模块调用的子模块；桩模块使用被它代替的模块的接口，可能做最少量的数据操作。

#### 2.集成测试

把**模块装配(即集成)** 在一起形成完整的软件包，在装配的同时进行测试。
> **模块相互间的协调和通信**是集成测试过程中的主要问题。
集成测试中将发现**软件设计中的错误**，也可能发现**需求说明中的错误**。

集成测试常用黑盒测试方法，可能使用一定的白盒测试。

集成测试策略:
（1）非渐增式集成测试(一次性组装)
（2）**渐增式集成测试**
边连接边测试，以随时发现连接中产生的问题。
在程序结构的高层使用**自顶向下** 策略，而在低层则使用**自底向上**策略，这种测试策略也称为三明治测试。

特别关注**关键模块** 的测试
> 关键模块特征：
1）与多个软件需求有关；
2）含有高层控制（位于程序结构的高层）；
3）本身是复杂的或是容易出错的；
4）含有确定的性能需求。

回归测试：重复已经进行过的测试。
回归测试的必要性：

+ 针对一个错误修复(Bug Fix)，需要做回归测试。
+ 回归测试最好自动化。

#### 3.确认测试

软件是否满足需求规格说明书中的确认标准。
确认测试**仅使用黑盒测试**方法

（1）α测试（模拟测试）：在开发场所和开发人员指导下**模拟实际运行环境和用户进行测试**
（2）β测试（现场测试）：组织典型用户在**实际使用环境下** 进行测试

场景测试：可以采用“场景”来规划确认测试工作

#### 4.其他

系统测试（超出了软工的范畴）：
把已经经过确认的软件纳入实际运行环境中，与其他系统成分组合在一起进行测试。
平行运行：
同时运行新开发出来的系统和将被它取代的旧系统，以便比较新旧两个系统的处理结果。

### 调试

任务：
在测试的基础上，进一步诊断和改正程序中潜在的错误。

过程：
① 确定程序中可疑错误的确切性质和位置；
② 对程序(设计，编码)进行修改，排除错误。

### 软件可靠性

可靠性：程序在给定的**时间间隔内** ，按照规格说明书的规定成功地运行的概率。
可用性：在给定的**时间点**， ~
> 可靠性与可用性的区别：
①可靠性意味着在0到t时间间隔内系统没有失效
②可用性意味着在时刻t，系统是正常运行的

## 第六章面向对象方法学

### 面向对象方法学概述

面向对象方法的设计思路：**基于对象分解**
**基于对象分解、以数据为核心；数据和操作封装在一起**

面向对象 (Object Oriented) ＝ 对象+ 消息传递 + 类 + 继承

### 面向对象方法学的基本概念

#### 对象

**对象** 是客观存在的事物抽象的结果；是其属性（状态、数据）和相关操作（行为、方法或服务）的封装体；对象之间通过消息传递实现相互作用
对象的表示：对象名、对象的静态特征(属性，属性值规定了对象可能具有的状态；一个对象的状态只能由该对象的操作来改变。)、对象的动态特征(操作，指该对象可以展现的外部服务；执行对象的操作可能改变对象的属性值。)

（2）对象的特点：

+ ① 以数据为中心
+ ② 实现了数据封装
+ ③ 本质上具有并行性
+ ④ 模块独立性好

#### 消息传递

消息传递：一个对象向另一个对象发送消息时，接受消息的对象经过解释、给予响应，这种对象之间进行通信的机制称为消息传递。**消息传递是对象与其外部世界相互通信的惟一途径。**
对象的公有操作主要是用来响应外来消息并为其他对象提供服务的，所以它们也被称为**外部服务**。

消息：是对象之间进行通信的机制；是要求某个对象执行其操作的规格说明。
消息的组成：①接收消息的对象名；②要执行的操作名；③相应的参数

#### 类

类是对具有相同属性和相同操作的一组相似对象的抽象描述，包括属性和操作两个主要部分。
**类是对象的模板，类的作用是用来创建对象；对象是类的实例。**

#### 继承

子类共享父类的属性和方法的机制。
子类可定义自己独有的属性和方法。
子类复用父类的定义，而不修改父类。
继承具有**多重性和传递性**。

#### 多态性

多态是指同一个命名可具有不同的语义。

在类等级的不同层次中，不同的类可以共享同一个操作名；
然而不同层次中的每个类却各自按自己的需要来实现这个操作。

#### 重载

#### 面向对象软件过程模型：喷泉模型

体现了面向对象软件开发**不同阶段之间的迭代和无缝过渡** 特性

**面向对象方法与结构化方法的区别**：
（1）面向对象方法基于对象分解（软件系统由对象组成，复杂的软件对象由比较简单的对象组合而成）。结构化方法基于功能分解。
（2）面向对象方法开发软件的各阶段之间采用一致的表示法；容易实现阶段之间的反复迭代、不断的充实和扩充对象、逐步深化对系统的认识。结构化方法开发软件的不同阶段之间需转换;强调需求分析的准确和完善。

### 面向对象建模

三种模型：
（1）描述系统数据结构的对象模型；
（2）描述系统控制结构的动态模型；
（3）描述系统功能的功能模型。
一个典型的软件系统组合了上述三种模型的内容：使用数据结构(对象模型)、执行操作(动态模型)、完成数据值的变化(功能模型) 。

对象模型是对模拟客观世界实体的对象以及对象彼此间的关系的映射、描述了系统的静态结构，包括：类(对象)的属性和操作、以及它们之间的关系

表示关系的图形符号：关联，表示两个类的**对象之间** 存在某种语义上的**联系**（普通和限定，关联类，关联的角色），聚集，表示整体对象与部分对象之间的关系（共享聚集，组合聚集）
泛化关系指出：类与类之间存在“一般-特殊”关系。

动态模型表示瞬时的、行为化的系统的“控制”性质，它
规定了对象模型中的对象的合法变化序列。
状态图来描绘对象的状态、触发状态转换的事件以及对象的行为（对事件的响应）。

功能模型表示变化的系统的“功能”性质，它指明了系统应该“做什么”，因此更直接地反映了用户对目标系统的需求
功能模型由一组**数据流图（DFD）** 组成
以**用例图** 建立功能模型的是用例模型

针对每个类建立的动态模型，描述了类实例的生命周期或运行周期 （对象模型&动态模型）
状态转换驱使行为发生，这些行为在数据流图中被映射成处理，在用例图中被映射成用例，它们同时与类图中的服务相对应 （动态模型&功能模型）
功能模型中的用例对应于复杂对象提供的服务，简单的用例对应于更基本的对象提供的服务 （功能模型&对象模型）

## 第七章面向对象分析（OOA）

### 面向对象分析建模过程

面向对象分析，就是 **抽取和整理用户需求并建立问题域精确模型的过程。**

分析过程：
寻找类与对象
识别结构
识别主题
定义属性
建立动态模型
建立功能模型
定义服务

分析系统的三要素：
①静态结构(对象模型)
②交互次序(动态模型)
③数据变换(功能模型)

五个层次：
主题层
类与对象层
结构层
属性层
服务层

### 需求陈述

需求陈述应该阐明“做什么”而不是“怎样做”。

### 建立对象模型

信息来源：
需求陈述、应用领域知识及常识

步骤：
(1)确定类&对象：识别候选者、筛选
对象是问题域中有意义的事物的抽象
非正式分析：名 词：作为类&对象的候选者。
形容词：作为确定属性的线索。
动 词：作为服务（操作）的候选者。

(2)确定关联（关联）

(3)划分主题

(4)确定属性

(5)识别继承关系

### 建立动态模型

在一些系统中，需要了解在所有时间内对象的变化和对象之间关系的变迁，即时序关系。这就产生了一种与静态结构(对象模型)相对应的、与时间和变化有关的内容，即动态模型。
步骤：
1、编写每个功能对应的典型交互行为的脚本（正常的和异常的）
2、根据每个脚本画**事件追踪图**
3、根据事件追踪图画每个类(对象)的**状态图**

### 建立功能模型

功能模型由一组**数据流图**或者一组**用例图**组成

### 定义服务

（1）常规操作：
访问类中定义的每个属性的操作（读、写属性的值）

（2）从（状态图）事件导出的操作：
当对象接收到事件后，在事件驱动下完成相应的操作

（3）与功能模型中的处理或用例对应的操作：
将完成每个处理或用例的功能定义成为相应对象的操作

## 第八章面向对象设计（OOD）

### 面向对象设计的准则

在面向对象分析模型基础上运用面向对象方法进行系统设计，目标是**产生一个符合具体实现条件的设计模型。**

OOA和OOD的区别和联系：
**OOA和OOD采用一致的概念与原则**，但属于软件生命周期的不同阶段，有不同的目标。
OOA目标是建立一个**直接映射问题域的OOA模型**
OOD目标是产生一个**可以实现的OOD模型**

面向对象设计的任务
（1）系统设计：
确定实现系统的策略和**目标系统的高层结构**，即把紧密相关的**对象(类)、关系**等设计元素包装成子系统。
（2）对象（类）的设计：
**对每个类的属性和操作进行详细设计**；确定解空间中类、关联、接口的形式；确定实现操作的算法。

(1) 模块化：对象就是模块
(2) 抽象化：过程抽象、数据抽象、参数化抽象
(3) 信息隐藏：封装性实现
(4) 弱耦合：交互耦合（松散）、继承耦合（紧密）
(5) 强内聚：服务内聚、类内聚、一般/特殊内聚
(6) 可重用：尽量使用已有类；设计新类时考虑可重复使用性。

### 启发规则

1．设计结果应该清晰易懂：用词一致、使用已有协议、减少消息模式的数目、避免模糊的定义
2．一般/特殊结构的深度应适当：类等级层次数(7±2原则)
3．设计简单的类：避免包含过多属性、类定义明确、简化对象间的合作关系、不要提供太多服务
4．使用简单的协议：一般消息中参数不超3个
5．使用简单的服务
6．把设计变动减至最小

### 系统的分解

各个子系统之间应该具有尽可能简单、明确的接口。接口确定了交互形式和通过子系统边界的信息流，但是无须规定子系统内部的实现算法。

OOD阶段的工作：
按实现条件对OOA模型进行调整，并**补充几个与现实有关、新的组成部分**

> 与实现有关的因素：
图形用户界面
硬件、操作系统及网络
数据管理系统
其他（编程语言、可复用构件库……）

问题域子系统、人机交互子系统、任务管理子系统、数据管理子系统。

子系统交互的两种方式：
1．客户—供应商关系（**尽量使用**）
了解供应商的子系统接口
2．平等伙伴关系
每个子系统都可能调用其他子系统，因此需要了解别的子系统的接口

### 子系统的设计

（1）问题域部分设计（业务领域层）：
根据实现条件（编程语言、可复用构件、设备性能、存储方案等），**对OOA中建立的对象模型做必要的修改、调整和细节补充。**
> 1.调整需求
2.重用已有的类（进行不同程度的复用）
3.按编程语言调整继承关系

（2）人机交互部分设计（用户界面层）：
根据选用的图形用户界面（GUI）系统和特定用户对人机界面的要求，定义关于人机界面的类与对象及其关系。有利于隔离界面支持系统的变化对问题域部分的影响
主要解决：用户如何命令系统，系统如何向用户提供信息。

（3）任务管理部分设计（系统层）：
确定各类任务,并把任务分配给适当的硬件或软件去执行。
考虑分布方案之前，将系统暂时看作集中式的；
确定分布方案之后，将对象分布在各个结点(处理机)上，每个结点(处理机)上的类作为一个包。

（4）数据管理部分设计（持久层）：
根据选定的数据管理系统，设计负责对象存储和检索的系统组成部分。

设计类中的服务：
将动态模型中对象的行为、功能模型中的处理，转换成由适当的类所提供的服务
1．设计实现服务的算法、算法的数据结构
2．定义内部类和内部操作（存放执行算法时产生的中间结果；将高层操作分解、引入新的低层操作。）

### 设计关联

两个对象之间关联的实现：
单向关联
双向关联（指针集合）

### 设计优化

确定优先级
提高效率的几项技术：
（1）增加冗余关联以提高访问效率
（2）调整查询次序
（3）保留派生属性
调整继承关系：
（1）抽象与具体
（2）为提高继承程度而修改类定义
（3）利用委托实现行为共享

## 第九章面向对象实现

面向对象语言的优点：
一致的表示方法
可重用性
可维护性

### 面向对象程序编码风格

1. 提高可重用性
2. 提高可扩充性
3. 提高健壮性（遇到异常情况，有相应处理方法，系统不崩溃）

### 面向对象测试策略

从小型测试到大型

单元测试 -> 集成测试 -> 确认测试 -> 系统测试

#### 面向对象的单元测试

（1）最小的可测试单元：封装起来的类&对象

（2）不能孤立的测试单个操作，应该把操作作为类的一部分进行测试

#### 面向对象的集成测试

两种策略：
（1）基于**线程**的测试策略：
把响应系统的一个输入或一个事件所需要的**一组类集成起来作为一个线程**；分别集成并测试每个线程。
（2）基于**使用**的测试策略：
首先**测试独立类（服务器类）**；
再逐层**测试依赖类（客户类）**；
直到把整个软件系统构造完成。

#### 面向对象的确认测试

集中检查**用户可见的动作和用户可识别的输出**

根据动态模型（描述系统行为的脚本）来设计确认测试用例

### 设计测试用例

测试单个类的方法主要有随机测试、划分测试和基于故障的测试3种。
面向对象的测试用例设计：
对被测试的类，设计适当的操作序列以检查类的状态

随机测试: 让类实例随机地执行一些类内定义的操作

划分测试：**将操作分类**，然后设计测试用例以测试划分出的每个类别
①基于状态的划分：
根据**类操作改变类状态的能力**来划分类操作
②基于属性的划分:
根据**操作使用某个关键属性的情况**划分类操作
③基于功能的划分：根据**操作完成的功能**来划分类操作

基于故障的测试（类似于错误推测法）:
首先推测软件中可能有的错误，然后设计最可能发现这些错误的测试用例

## 第十章软件维护与软件再工程

### 软件维护

定义：
在软件产品交付给用户之后，为了改正软件测试阶段未发现的缺陷，改进软件产品的性能，补充软件产品的新功能等，所进行的修改软件的过程。

分类：
纠错性维护
适应性维护
完善性维护
预防性维护

软件维护的特点：
(1)结构化维护
结构化维护是在软件开发的早期应用软件工程方法学的结果。虽然有了软件的完整配置并不能保证维护中没有问题，但是确实能减少精力的浪费并且能提高维护的总体质量。
(2)非结构化维护
非结构化维护需要付出很大代价(浪费精力并且遭受挫折的打击)，这种维护方式是没有使用良好定义的方法学开发出来的软件的必然结果

### 软件的可维护性

定义：
纠正软件系统出现的错误和缺陷，以及为满足新的要求进行修改、扩充或适应的容易程度。

维护困难的原因：

1. 文档不全、质量差、开发过程不注意采用好的方法，忽视程序设计风格等。
2. 维护要求为适应环境变化或需求变化而提出的

### 软件逆向工程与再工程

预防性维护

逆向工程是从源代码中抽取出来的设计信息。作为逆向工程的评价，要求抽取出来的信息的**抽象程度越高越好**。
逆向工程中得到的信息抽象层次(从低到高)；软件过程的设计表示、程序和数据结构信息、数据和控制流模型和实体、关系模型。

再工程，它不仅能从已存在的程序中重新获得设计信息，而且还能使用这些信息来改建或重构现有的系统．以改进它的综合质量。

（**重要**）在软件开发过程中始终强调软件可维护性的原因：
一个计算机应用系统，由于需求和环境的变化、以及自身暴露的问题，在交付用户使用后，对它进行维护是不可避免的。统计和估测结果表明，信息技术中硬件费用一般占35%，软件费用占65%，而软件后期维护费用有时竟高达软件总费用的70%以上，所有前期开发费用仅占30%。

## 第十一章软件工程项目管理

### 软件项目管理

通过计划、组织和控制等一系列活动，合理地配置和使用各种资源，以便**在预定成本和期限内开发出符合既定需求的软件的过程。**
先于任何技术活动之前开始，并且贯穿于软件的整个生命周期之中。
制定计划的基础是**工作量估算和完成期限估算。**

### 常见CASE技术的开发工具简介

计算机辅助软件工程(Computer Aided Software Engineering，CASE)技术正在成为一种最有力的软件开发技术。
是软件工具和软件方法的结合。着眼于软件分析和设计以及程序实现维护的自动化，从软件生存期的两端解决了软件生产率的问题。

基于CASE技术的开发工具
Microsoft Visio
Microsoft Project
Rational Rose
PowerDesigner

### 成本估算

1. 自顶向下的估算方法
2. 自底向上的估算法
3. 差别估算法

1.代码行技术
估计实现软件功能所需要的源程序行数。
最小规模a、最大规模b 、最可能的规模m，分别算出这3种规模的平均值，则规模：$$L= \frac{a + 4m + b}{6}$$
单位：代码行数（LOC）或千行代码数（KLOC）

2.功能点技术
根据对软件信息域特性和复杂性的评估结果，计算功能点数，以此度量软件规模。
(1)信息域特性：
①输入项数Inp（给软件提供的数据）
②输出项数Out（屏幕、报表、出错信息等）
③查询数Inq（“联机输入～联机输出”响应对的数目）
④主文件数Maf，数据的一个逻辑集合（一个独立文件、一个数据库表等）
⑤外部接口数Inf（机器可读的全部接口，如磁盘上的文件）
（3）估算功能点的步骤：
①计算未调整的功能点数UFP:
UFP=a1×Inp+a2×Out+a3×Inq+a4×Maf+a5×Inf
其中： ai(1≤i≤5)是信息域特性系数
②计算技术复杂性因子TCF:
TCF=0.65 + 0.01×∑Fi（0.65~1.35）
③计算功能点数FP:
FP=UFP×TCF

功能点数与所用的编程语言无关

每一个项目任务的解决都需要花费若干工作量；每个工作量单位都对应于一定的货币成本、可以由此作出成本估算。
工作量单位：人月（PM）
工作量是软件规模（KLOC或FP）的函数

1. 静态单变量模型
2. 动态多变量模型
3. COCOMO2模型，将软件开发工作量表示成代码行数的非线性函数

> 三个层次的估算模型：
（1）应用系统组成模型：主要用于估算构建原型的工作量、构建原型时大量使用已有的构件。
（2）早期设计模型：适用于体系结构设计阶段。
（3）(**重要**)后体系结构模型：适用于完成体系结构设计之后的软件开发阶段。

### 计划和组织

详细说明了所需软件工作及如何实现。
应在项目开始初期制定出，并随着工程的进展不断地加以精化。
在每一次后续的需求精化时，也应同时精化资源映射，项目规模估算和工程进度。

几种项目组人员组织与管理
主程序员组织形式
民主小组程序员形式
层次小组程序员组

### 进度计划与控制

项目管理的目标：
定义一个适用于当前项目的**任务集合**，识别出**关键任务**，跟踪**关键任务的进展** 状况，及时发现拖延进度的情况并采取适当解决措施。

描述进度计划的工具
1.WBS 工作分解结构
> 以可交付成果为导向，对项目要素进行逐层的分组，它归纳和定义了项目的整个工作范围，每下降一层代表对项目工作的更详细定义。

2.Gantt 图：甘特图是制定进度计划的工具
动态地反映软件开发进展，
缺点：没有反映多个任务彼此间的依赖关系；进度计划的关键部分不明确；进度计划中有潜力的部分不明确、往往造成潜力的浪费。
> 甘特图内容：
（1）标明各个阶段任务的计划开始时间、计划完成时间；
（2）标明各个任务完成的标志（文档；评审）；
（3）标示当前进度。

3.工程网络图：描述各项任务的开始时间和结束时间，描述各个任务彼此间的依赖关系
> 各有向边表示要完成的任务，边上标注任务的名称；边上的数字表示完成任务的持续时间.
图中有数字编号的结点是任务的起点和终点（称为事件）。

关键路径：从项目开始到项目完成有许多条路径，在整个网络图中**最长的路径**就叫关键路径。
机动时间：不在关键路径上的作业有一定程度的机动余地，其实际开始时间可以比预定时间晚一些，或者实际持续时间可以比预定的持续时间长一些，而并不影响工程的结束时间。

（**重要**）工程网络图与Gantt图的比较：
工程网络图能够显式地定义事件及作业之间的依赖关系，Gantt图只能隐含地表示这种关系。
但是Gantt图的形式比工程网络更简单更直观，为更多的人所熟悉。
因此，应该同时使用这两种工具制订和管理进度计划，使它们互相补充、取长补短。

### 风险管理

两个显著特点：不确定性和损失
风险识别与分类
风险评估与分析
风险策划与管理
风险规避与监控

### 配置管理

软件配置管理是在软件的整个生命周期内管理变化的一组活动。这组活动用来：
①标识变化；②控制变化；③确保适当地实现变化；④向需要知道这类信息的人报告变化。

（1）软件配置项：软件过程中产生的全部信息。包括：
①计算机程序(源代码和可执行程序)；
②描述计算机程序的文档(供技术人员或用户使用)；
③数据(程序内包含的或在程序外的)。

（2）基线：
基线是通过了正式复审的软件配置项。
基线是已经通过了正式复审的规格说明或中间产品，它可以作为进一步开发的基础，并且只有通过正式的变化控制过程才能改变它。

软件配置管理过程的五项任务：
（1）标识软件配置中的对象（单独命名每个配置项）
（2）版本控制（管理不同版本的配置对象）
（3）变化控制（评估、跟踪、和复审所有变化）
（4）配置审计（确保适当地实现了所需要的变化。配置审计采取的措施：①技术复审；②软件配置审计）
（5）状态报告（书写配置状态报告，回答下述问题：
①发生了什么事? ②谁做的这件事? ③这件事是什么时候发生的? ④它将影响哪些其他事物?）

### 能力成熟度模型CMM

CMM用于改进软件开发和维护的过程（适于软件开发组织）
CMM 为大型软件项目的招投标活动提供一种全面而客观的评审依据

五个等级:
1.初始级:软件过程混乱无序
2.可重复级:建立了基本的项目管理过程,能够跟踪成本、进度、功能和质量。类似的软件项目可再次取得成功。
3.已定义级:定义了完整的软件过程（标准化和文档化），所有的开发都按照此标准过程完成。
4.已管理级:软件机构定量地管理开发过程和软件产品
5.优化级:定量管理并不断改进软件过程

软件质量
